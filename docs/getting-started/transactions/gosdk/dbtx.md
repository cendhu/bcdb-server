---
id: dbtx
title: Database Administration Transaction
---

# Database Administration Transaction

The database administration transaction can be used for
  1. [Creation of new databases without index](#1-creation-of-databases)
  2. [Creation of a new database with index definition](#3-creation-of-database-with-index-definition)
  3. [Deletion of existing databases](#4-deletion-of-existing-databases)

Note that all database administration transactions must be submitted by the admin.

> As a pre-requisite, we need to first [create a connection](../../pre-requisite/gosdk#creating-a-connection-to-the-orion-cluster) and [open a database session](../../pre-requisite/gosdk#opening-a-database-session).

> In addition to this example, you can download and use the database administration transaction example from the go-sdk examples folder: [orion-sdk-go/examples/api/db_tx/db_tx.go](https://github.com/hyperledger-labs/orion-sdk-go/blob/main/examples/api/db_tx/db_tx.go)

Once a [database session](../../pre-requisite/gosdk#opening-a-database-session) is created, we can call `session.DBsTx()` to start the database administration transaction context. On this transaction context, we have the support for following method calls:

```go 
// DBsTxContext abstraction for database management transaction context
type DBsTxContext interface {
	// CreateDB creates new database along with index definition for the query.
	// The index is a map of attributes/fields in json document, i.e., value associated
	// with the key, to its value type. For example, map["name"]types.IndexAttributeType_STRING
	// denotes that "name" attribute in all json documents to be stored in the given
	// database to be indexed for queries. Note that only indexed attributes can be
	// used as predicates in the query string. Currently, we support the following three
	// value types: STRING, BOOLEAN, and INT64
	CreateDB(dbName string, index map[string]types.IndexAttributeType) error
	// DeleteDB deletes database
	DeleteDB(dbName string) error
	// Exists checks whenever database is already created
	Exists(dbName string) (bool, error)
	// Commit submits transaction to the server, can be sync or async.
	// Sync option returns tx id and tx receipt and
	// in case of error, commitTimeout error is one of possible errors to return.
	// Async returns tx id, always nil as tx receipt or error
	Commit(sync bool) (string, *types.TxReceipt, error)
	// Abort cancel submission and abandon all changes
	// within given transaction context
	Abort() error
	// CommittedTxEnvelope returns transaction envelope, can be called only after Commit(), otherwise will return nil
	CommittedTxEnvelope() (proto.Message, error)
}
```

## (1) Creation of Databases

### (1.1) Source Code
The following is the source code to create two new databases named `db1` and `db2`.
```go
package main

import (
	"fmt"
	"strconv"
)

func main() {
	db, err := createConnection()
    // if err is not nil, print and return

	session, err := openSession(db)
    // if err is not nil, print and return

	dbtx, err := session.DBsTx()
    // if err is not nil, print and return

	err = dbtx.CreateDB("db1", nil)
    // if err is not nil, print and return

	err = dbtx.CreateDB("db2", nil)
    // if err is not nil, print and return

	txID, receipt, err := dbtx.Commit(true)
	// if err is not nil, print and return

	fmt.Println("transaction with txID " + txID + " got committed in the block " + strconv.Itoa(int(receipt.GetHeader().GetBaseHeader().GetNumber())))
}
```

### (1.2) Source Code Commentary
For simplicity, not all `errors` are handled in this code. Further, the implementation of `createConnection()` and `openSession()` can be found [here](../../pre-requisite/gosdk).

The `session.DBsTx()` starts a new database administration transaction and returns the database administration transaction context. We can then perform
all administrative activities using the transaction context. The `dbtx.CreateDB("db1", nil)` creates the database named `db1` while `dbtx.CreateDB("db2", "nil")`
creates the database named `db2`. Then, the transaction is committed by calling `dbtx.Commit(true)`. The argument `true` denotes that the synchronous
submission. As a result, the `Commit()` would return the transaction receipt if this transaction gets committed before the `TxTimeout` configured in
the `openSession()`.

The structure of `txReceipt` can be seen [here]. The user can store this `txReceipt` as it is a committment used to verify the proof generated by the server.

## (2) Checking the Existence of Databases

### Source Code
```go
package main

import (
	"fmt"
)

func main() {
	db, err := createConnection()
    // if err is not nil, print and return

	session, err := openSession(db)
    // if err is not nil, print and return

	dbtx, err := session.DBsTx()
    // if err is not nil, print and return

	exist, err := dbtx.Exists("db1")
    // if err is not nil, print and return
	fmt.Println("Does database exist?", exist)

	exist, err = dbtx.Exists("db2")
    // if err is not nil, print and return
	fmt.Println("Does database exist?", exist)

	err = dbtx.Abort()
    // if err is not nil, print and return
}
```

### Source Code Commentary
For simplicity, not all errors are handled in this code. Further, the implementation of `createConnection()` and `openSession()` can be found [here](../../pre-requisite/gosdk).

The `session.DBsTx()` starts a new database administration transaction and returns the database administration transaction context. We can then perform all
administrative activities using the transaction context.

The `dbtx.Exists("db1")` and `dbtx.Exists("db2")` check whether the given databases exist or not. It returns a boolean flag where `true` denotes that the
database exist while `false` denotes that the database does not exist.

As we are executing a read-only query, it is not necessary to commit the transaction and hence, we are aborting it by calling `dbtx.Abort()`. If we need to record
all read-only transactions history into the centralized ledger, then it is advisable to do `dbtx.Commit()` rather than `dbtx.Abort()`.

## (3) Creation of Database with Index Definition

### Source Code
The following is the source code to create a new database named `db8` with index definition.

```go
package main

import (
	"fmt"
	"strconv"

	"github.com/hyperledger-labs/orion-server/pkg/types"
)

func main() {
	db, err := createConnection()
    // if err is not nil, print and return

	session, err := openSession(db)
    // if err is not nil, print and return

	dbtx, err := session.DBsTx()
    // if err is not nil, print and return

	index := map[string]types.IndexAttributeType{
		"attr1": types.IndexAttributeType_BOOLEAN,
		"attr2": types.IndexAttributeType_NUMBER,
		"attr3": types.IndexAttributeType_STRING,
	}
	err = dbtx.CreateDB("db8", index)
    // if err is not nil, print and return

	txID, receipt, err := dbtx.Commit(true)
	// if err is not nil, print and return

	fmt.Println("transaction with txID " + txID + " got committed in the block " + strconv.Itoa(int(receipt.GetHeader().GetBaseHeader().GetNumber())))
}
```

### Source Code Commentary
For simplicity, not all errors are handled in this code. Further, the implementation of `createConnection()` and `openSession()` can be found [here](../../pre-requisite/gosdk).

The `session.DBsTx()` starts a new database administration transaction and returns the database administration transaction context. We can then perform all
administrative activities using the transaction context. To define an index for a database to be created, first, we need to create the index definition.
The above code creates the following index:
```go
	index := map[string]types.IndexAttributeType{
		"attr1": types.IndexAttributeType_BOOLEAN,
		"attr2": types.IndexAttributeType_NUMBER,
		"attr3": types.IndexAttributeType_STRING,
	}
```
This index would dicdate the orion-server to create index for three attributes in the JSON document stored in the database to be created. These attributes
are `attr1`, `attr2`, and `attr3`. The type of each of these attributes are also provided in the index defintion. 

Once the index is defined, the database with this index is created by calling `dbtx.CreateDB("db8", index)`. 

Finally, the transaction is committed by calling `dbtx.Commit(true)`. The argument `true` denotes that the synchronous
submission. As a result, the `Commit()` would return the transaction receipt if this transaction gets committed before the `TxTimeout` configured in
the `openSession()`.

The structure of `txReceipt` can be seen [here]. The user can store this `txReceipt` as it is a committment used to verify the proof generated by the server.

## (4) Deletion of Existing Databases

### Source Code
```go
package main

import (
	"fmt"
	"strconv"
)

func main() {
	db, err := createConnection()
    // if err is not nil, print and return

	session, err := openSession(db)
    // if err is not nil, print and return

	dbtx, err := session.DBsTx()
    // if err is not nil, print and return

	err = dbtx.DeleteDB("db1")
    // if err is not nil, print and return

	err = dbtx.DeleteDB("db2")
    // if err is not nil, print and return

	txID, receipt, err := dbtx.Commit(true)
	// if err is not nil, print and return

	fmt.Println("transaction with txID " + txID + " got committed in the block " + strconv.Itoa(int(receipt.GetHeader().GetBaseHeader().GetNumber())))
}
```

### Source Code Commentary
For simplicity, not all errors are handled in this code. Further, the implementation of `createConnection()` and `openSession()` can be found [here](../../pre-requisite/gosdk).

The `session.DBsTx()` starts a new database administration transaction and returns the database administration transaction context. We can then perform all
administrative activities using the transaction context.

The `dbtx.DeleteDB("db1")` and `dbtx.DeleteDB("db2")` delete databases `db1` and `db2`, respectively.

Then, the transaction is committed by calling `dbtx.Commit(true)`. The argument `true` denotes that the synchronous
submission. As a result, the `Commit()` would return the transaction receipt if this transaction gets committed before the `TxTimeout` configured in
the `openSession()`.

The structure of `txReceipt` can be seen [here]. The user can store this `txReceipt` as it is a committment used to verify the proof generated by the server.
